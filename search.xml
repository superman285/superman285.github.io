<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>永恒のOP</title>
      <link href="/2019/02/22/%E6%B0%B8%E6%81%92%E3%81%AEOP/"/>
      <url>/2019/02/22/%E6%B0%B8%E6%81%92%E3%81%AEOP/</url>
      
        <content type="html"><![CDATA[<h2 id="紫罗兰永恒花园OP"><a href="#紫罗兰永恒花园OP" class="headerlink" title="紫罗兰永恒花园OP"></a>紫罗兰永恒花园OP</h2><p>心中永恒不变的花园。</p><blockquote><p>我的眼睛虽被夜色这笔，夜空之中却闪耀着繁星。</p></blockquote><video controls src="violet.mp4" width="1080" height="600"><br></video>]]></content>
      
      
      <categories>
          
          <category> Entertain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACG </tag>
            
            <tag> 紫罗兰永恒花园 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>one</title>
      <link href="/2019/02/22/one/"/>
      <url>/2019/02/22/one/</url>
      
        <content type="html"><![CDATA[<p>我是文章一  测试合适字体</p><h1 id="我是h1"><a href="#我是h1" class="headerlink" title="我是h1"></a>我是h1</h1><p>五福手势的</p><h2 id="我是h2"><a href="#我是h2" class="headerlink" title="我是h2"></a>我是h2</h2><p>三生三世</p><h3 id="我是h3"><a href="#我是h3" class="headerlink" title="我是h3"></a>我是h3</h3><p>三生三世</p><h4 id="我是h4"><a href="#我是h4" class="headerlink" title="我是h4"></a>我是h4</h4><p>少时诵诗书所所所所所</p><h5 id="我是h5"><a href="#我是h5" class="headerlink" title="我是h5"></a>我是h5</h5><p>少时诵诗书所所所所所所所所</p><h6 id="我是h6"><a href="#我是h6" class="headerlink" title="我是h6"></a>我是h6</h6><p>少时诵诗书所所所所所</p>]]></content>
      
      
      <categories>
          
          <category> Entertain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity </tag>
            
            <tag> BlockChain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具类合约或库的使用</title>
      <link href="/2019/02/22/%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%90%88%E7%BA%A6%E6%88%96%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/22/%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%90%88%E7%BA%A6%E6%88%96%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>把工具功能写成合约，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contract Console &#123;</span><br><span class="line">    event LogUint(string, uint);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">string s , uint x</span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">    emit LogUint(s, x);</span><br><span class="line">    &#125;</span><br><span class="line">event LogInt(string, int);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">string s , int x</span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">emit LogInt(s, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用时，import “./Console.sol”</p><p>contract myContract is Console{ </p><p>log(“timeNow”,now); </p><p>}</p><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>把工具功能写成库library，如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">library Console &#123;</span><br><span class="line">    event LogUint(string, uint);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">string s , uint x</span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">    emit LogUint(s, x);</span><br><span class="line">    &#125;</span><br><span class="line">    event LogInt(string, int);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">string s , int x</span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">    emit LogInt(s, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==注意==</p><p>在library中我们不能定义任何storage类型的变量。因为library只是意味着代码的重用而不是进行state的状态管理。使用前再查询确认下。</p><hr><p>引用时，import {Console} from “./Console.sol”</p><p>contract myContract {</p><p>​    Console.log(“timeNew”,now);</p><p>}</p><p>访问library中的数据或方法时，使用点，libraryName.xxx来访问。</p>]]></content>
      
      
      <categories>
          
          <category> BlockChain </category>
          
          <category> Solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solidity </tag>
            
            <tag> BlockChain </tag>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回到解放前</title>
      <link href="/2019/02/22/%E5%9B%9E%E5%88%B0%E8%A7%A3%E6%94%BE%E5%89%8D/"/>
      <url>/2019/02/22/%E5%9B%9E%E5%88%B0%E8%A7%A3%E6%94%BE%E5%89%8D/</url>
      
        <content type="html"><![CDATA[<p>真的是回到解放前</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>聊聊geth和私链节点</title>
      <link href="/2019/01/20/%E8%81%8A%E8%81%8Ageth%E5%92%8C%E7%A7%81%E9%93%BE%E8%8A%82%E7%82%B9/"/>
      <url>/2019/01/20/%E8%81%8A%E8%81%8Ageth%E5%92%8C%E7%A7%81%E9%93%BE%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h5 id="创世区块"><a href="#创世区块" class="headerlink" title="创世区块"></a>创世区块</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"config"</span>: &#123;</span><br><span class="line">        //区块链的ID，你随便给一个就可以</span><br><span class="line">        "chainId": 21,</span><br><span class="line">        //下面三个参数暂时不知道干啥的</span><br><span class="line">        //等我知道了补上，或者有哪位大神知道</span><br><span class="line">        //可以在评论里指点我，谢谢</span><br><span class="line">        "homesteadBlock": 0,</span><br><span class="line">        "eip155Block": 0,</span><br><span class="line">        "eip158Block": 0</span><br><span class="line">    &#125;,</span><br><span class="line">  //用来预置账号以及账号的以太币数量，应该也就是所谓的预挖</span><br><span class="line">  //我这里不需要预挖，所以给了个空对象</span><br><span class="line">  //如果需要可以这样加</span><br><span class="line">  //"alloc": &#123;</span><br><span class="line">  //"0x0000000000000000000000000000000000000001": &#123;"balance": "111111111"&#125;,</span><br><span class="line">  //"0x0000000000000000000000000000000000000002": &#123;"balance": "222222222"&#125;</span><br><span class="line">  //&#125;</span><br><span class="line">  "alloc"      : &#123;&#125;,</span><br><span class="line">  //币基地址，也就是默认的钱包地址，因为我没有地址，所以全0，为空</span><br><span class="line">  //后面运行Geth后创建新账户时，如果Geth发现没有币基地址，会默认将第一个账户的地址设置为币基地址</span><br><span class="line">  //也就是矿工账号</span><br><span class="line">  "coinbase"   : "0x0000000000000000000000000000000000000000",</span><br><span class="line">  //挖矿难度，你可以随便控制哦，这里设置的难度比较小，因为我喜欢钱来得快</span><br><span class="line">  "difficulty" : "0x20000", //可以用小点的0x4000</span><br><span class="line">    //0x2ffffd大概 一分钟5~10个</span><br><span class="line">  //附加信息，随便填个文本或不填也行，类似中本聪在比特币创世块中写的报纸新闻</span><br><span class="line">  "extraData"  : "",</span><br><span class="line">  //gas最高限制，以太坊运行交易，合约等所消耗的gas最高限制，这里设置为最高</span><br><span class="line">  "gasLimit"   : "0x2fefd8",  //0xffffff为最高</span><br><span class="line">  //64位随机数，用于挖矿，注意他和mixhash的设置需要满足以太坊黄皮书中的要求</span><br><span class="line">  //直接用我这个也可以</span><br><span class="line">  "nonce"      : "0x0000000000000042",</span><br><span class="line">  //与nonce共同用于挖矿，注意他和nonce的设置需要满足以太坊黄皮书中的要求</span><br><span class="line">  "mixhash"    : "0x0000000000000000000000000000000000000000000000000000000000000000",</span><br><span class="line">  //上一个区块的Hash值，因为是创世块，石头里蹦出来的，没有在它前面的，所以是0</span><br><span class="line">  "parentHash" : "0x0000000000000000000000000000000000000000000000000000000000000000",</span><br><span class="line">  //创世块的时间戳，这里给0就好</span><br><span class="line">  "timestamp"  : "0x00"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化创世节点：</p><p>geth –datadir ./data init genesis.json</p><p>启动节点</p><p>geth –datadir ./data –networkid 15 –port 30303 –rpc –rpcaddr 0.0.0.0 –rpcport 8545 –rpcapi ‘db,net,eth,web3,personal’ –rpccorsdomain ‘*’ –nat “any” –nodiscover console</p><p>💡 <font style="color:white;background:mediumseagreen;padding:3px 6px;font-weight:bold;line-height:28px">千万注意引号是英文的 特别坑</font></p><h5 id="GETH命令参数详解"><a href="#GETH命令参数详解" class="headerlink" title="GETH命令参数详解"></a>GETH命令参数详解</h5><table><thead><tr><th>geth命令参数</th><th>参数含义</th></tr></thead><tbody><tr><td>console</td><td>指启动节点后启用交互式js命令行</td></tr><tr><td>datadir</td><td>指定数据存放目录</td></tr><tr><td>networkid</td><td>以太坊网络标识符，1代表主网，3Ropsten，4Rinkeby，34都为测试网，<br>默认为1，填个大点的代表私有链</td></tr><tr><td>port</td><td>网卡监听端口号，不同计算机节点通过这个连接</td></tr><tr><td>–rpc</td><td>启用http-rpc服务器，允许远程指令访问</td></tr><tr><td>rpcaddr 0.0.0.0</td><td>允许任意有效的ip地址连接</td></tr><tr><td>rpcport</td><td>http-rpc服务器监听端口，即geth启动rpc服务的端口为8545(默认值)</td></tr><tr><td>rpcapi</td><td>提供的可供调用的api模块</td></tr><tr><td>rpccorsdomain</td><td>可以跨域访问的域名列表 (浏览器想连接上geth需要有此项)，<br>*代表所有</td></tr><tr><td>nat</td><td>端口映射机制，默认any</td></tr><tr><td>nodiscover</td><td>禁用节点发现机制(手动添加节点)</td></tr><tr><td>–identity</td><td>自定义节点名‘name’</td></tr><tr><td>–dev</td><td>开发者模式，自动分配一个不需要解锁的账户而且会得自动挖矿</td></tr></tbody></table><font style="color:white;background:mediumseagreen;padding:3px 6px;font-weight:bold;line-height:28px">注意</font><p>–dev 使用POA共识网络，默认预分配一个开发者账户并且会自动开启挖矿。–dev可以不用创世块初始化</p><p>创世块中调节挖矿难度</p><p>–dev.period value | value为开发者模式下挖矿周期(0 = 仅在交易时)(默认: 0)</p><blockquote><p>geth –datadir ./data –networkid 15 –port 30303 –rpc –rpcaddr 0.0.0.0 –rpcport 8545 –rpcapi ‘db,net,eth,web3,personal’ –rpccorsdomain ‘*’ –nat “any” –nodiscover –identity “superman285” console 2&gt;gethprint.log</p></blockquote><p>信息不打印在命令行中，而是输出到gethprint.log文件中，</p><p>这时如果用miner.start() 会打出null而不是true，但是也开始挖矿了</p><p>geth命令参数详解：<a href="http://www.cnblogs.com/tinyxiong/p/7918706.html" target="_blank" rel="noopener">http://www.cnblogs.com/tinyxiong/p/7918706.html</a></p><p>geth的控制台可以定义变量，用js语法，可用var</p><font style="color:white;background:mediumseagreen;padding:3px 6px;font-weight:bold;line-height:28px">常用：</font><p>eth.accounts | eth.accounts[index]</p><p>eth.blockNumber</p><p>eth.getBalance(eth.accounts[0])</p><p>personal.newAccount(“password”)</p><p>personal.unlockAccount(address) | 可以address = eth.accounts[0]</p><p>miner.start() | miner.stop()</p><p>转账</p><p>eth.sendTransaction({from:user1,to:user2,value:web3.toWei(10,“ether”)})</p><p>转账10个eth，需要挖矿才能确认交易</p><p>单位换算</p><p>web3.toWei(10,“ether”)</p><p>geth指令 启动节点时如果带了 –dev 开发者模式 可以不用创世块genesis block来初始化 ?</p>]]></content>
      
      
      
        <tags>
            
            <tag> BlockChain </tag>
            
            <tag> Ethereum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS中的对象和原型</title>
      <link href="/2018/11/02/JS%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8E%9F%E5%9E%8B/"/>
      <url>/2018/11/02/JS%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8E%9F%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="JS里的对象"><a href="#JS里的对象" class="headerlink" title="JS里的对象"></a>JS里的对象</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><blockquote><p>对象就是一组键值对(key-value)集合,是无序的复合数据集合。类似map结构。</p></blockquote><p>一个对象的键值对之间，用逗号分隔。</p><p>💫键名如果是数值，会被自动转为字符串。</p><p>如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">1</span>p: <span class="string">'Hello World'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">'1p'</span>: <span class="string">'Hello World'</span>,</span><br><span class="line">  <span class="string">'h w'</span>: <span class="string">'Hello World'</span>,</span><br><span class="line">  <span class="string">'p+q'</span>: <span class="string">'Hello World'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对象两种调用属性方式，obj.pro | obj[‘pro’]。在上面这个栗子，只能用[‘’]的方式调用。</p><p>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.p(<span class="number">1</span>) <span class="comment">// 2</span></span><br><span class="line">obj[<span class="string">"p"</span>](<span class="number">1</span>) <span class="comment">// 2 ，第二种调用方法</span></span><br></pre></td></tr></table></figure><h4 id="表达式还是语句？"><a href="#表达式还是语句？" class="headerlink" title="表达式还是语句？"></a>表达式还是语句？</h4><p>如果行首是一个大括号，它到底是表达式还是语句？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;</span><br></pre></td></tr></table></figure><p>JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含<code>foo</code>属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签<code>foo</code>，指向表达式<code>123</code>。</p><font style="color:white;background:mediumseagreen;padding:3px 6px;font-weight:bold;">外面加上圆括号，理解为对象；不加圆括号，理解为代码块。</font><p>这种差异在<code>eval</code>语句（作用是对字符串求值）中反映得最明显。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">'&#123;foo: 123&#125;'</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">'(&#123;foo: 123&#125;)'</span>) <span class="comment">// &#123;foo: 123&#125;</span></span><br></pre></td></tr></table></figure><p>没有圆括号，<code>eval</code>将其理解为一个代码块；加上圆括号以后，就理解成一个对象。</p><h4 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h4><h5 id="读取属性"><a href="#读取属性" class="headerlink" title="读取属性"></a>读取属性</h5><p>点运算符和方括号运算符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p: &apos;Hello World&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.p // &quot;Hello World&quot;</span><br><span class="line">obj[&apos;p&apos;] // &quot;Hello World&quot;</span><br></pre></td></tr></table></figure><p>上面代码分别采用点运算符和方括号运算符，读取属性<code>p</code>。</p><p>请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo  <span class="comment">// 1</span></span><br><span class="line">obj[foo]  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>方括号更加灵活多样，方括号运算符内部还可以使用表达式，点号不行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj[<span class="string">'hello'</span> + <span class="string">' world'</span>]</span><br><span class="line">obj[<span class="number">3</span> + <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>数字键可以不加引号，因为自动转为字符串。数字键不能用点运算符，会被当成小数点，报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0.7</span>: <span class="string">'Hello World'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="string">'0.7'</span>] <span class="comment">// "Hello World"</span></span><br><span class="line">obj[<span class="number">0.7</span>] <span class="comment">// "Hello World"</span></span><br><span class="line">obj<span class="number">.0</span><span class="number">.7</span> <span class="comment">//报错，不可用点运算符。</span></span><br></pre></td></tr></table></figure><h5 id="属性的赋值"><a href="#属性的赋值" class="headerlink" title="属性的赋值"></a>属性的赋值</h5><p>点运算符和方括号运算符，除了读取，还可用于赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo = <span class="string">'Hello'</span>;</span><br><span class="line">obj[<span class="string">'bar'</span>] = <span class="string">'World'</span>;</span><br></pre></td></tr></table></figure><p>JavaScript 允许<font style="color:white;background:mediumseagreen;padding:3px 6px;font-weight:bold;">属性的“后绑定”</font>，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。</p><h5 id="查看所有属性"><a href="#查看所有属性" class="headerlink" title="查看所有属性"></a>查看所有属性</h5><p><code>Object.keys</code>，查看一个对象本身的所有属性(所有‘键’)，返回的是一个数组(Array)。</p><p>💡 技巧：想查看一个对象中有多少个键，使用<code>Object.keys(objxx).length</code>方法即可。</p><p>(或Object.keys(objxx)[‘length’])</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  key1: <span class="number">1</span>,</span><br><span class="line">  key2: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj);</span><br><span class="line"><span class="comment">// ['key1', 'key2']</span></span><br></pre></td></tr></table></figure><h5 id="delete命令"><a href="#delete命令" class="headerlink" title="delete命令"></a>delete命令</h5><p>用于删除对象的某个属性，删除成功后返回true</p><p>删除存在或不存在的属性，都会返回true；只有一种情况，该属性存在而且不得删除，delete才会返回false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// ["p"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// true</span></span><br><span class="line">obj.p <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// []</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'p'</span>, &#123;</span><br><span class="line">  value: <span class="number">123</span>,</span><br><span class="line">  configurable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.p <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码之中，对象<code>obj</code>的<code>p</code>属性是不能删除的，所以<code>delete</code>命令返回<code>false</code>（关于<code>Object.defineProperty</code>方法的介绍，请看《标准库》的 Object 对象一章）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.toString <span class="comment">// true</span></span><br><span class="line">obj.toString <span class="comment">// function toString() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><p>另外，需要注意的是，<code>delete</code>命令只能删除对象本身的属性，无法删除继承的属性（关于继承参见《面向对象编程》章节）。</p><p>上面代码中，<code>toString</code>是对象<code>obj</code>继承的属性，虽然<code>delete</code>命令返回<code>true</code>，但该属性并没有被删除，依然存在。这个例子还说明，即使<code>delete</code>返回<code>true</code>，该属性依然可能读取到值。</p><h5 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a>in运算符</h5><p><code>in</code>运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回<code>true</code>，否则返回<code>false</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="string">'p'</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>不能识别哪些属性是对象自身的，哪些属性是继承的。<code>toString</code>方法不是对象<code>obj</code>自身的属性，而是继承的属性。但是，<code>in</code>运算符不能识别，对继承的属性也返回<code>true</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="string">'toString'</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="for…in循环"><a href="#for…in循环" class="headerlink" title="for…in循环"></a>for…in循环</h5><p>该循环用来遍历一个对象的全部属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj[i]); | <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1  |  a</span></span><br><span class="line"><span class="comment">// 2  |  b</span></span><br><span class="line"><span class="comment">// 3  |  c</span></span><br></pre></td></tr></table></figure><p>下面是一个使用<code>for...in</code>循环，提取对象属性名的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">  y: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> props = [];</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  props[i++] = p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">props <span class="comment">// ['x', 'y']</span></span><br></pre></td></tr></table></figure><p>对象<code>obj</code>继承了<code>toString</code>属性，该属性不会被<code>for...in</code>循环遍历到，因为它默认是“不可遍历”的。</p><font style="color:white;background:mediumseagreen;padding:3px 6px;font-weight:bold;">hasOwnProperty</font><p>判断某个属性是不是对象自身的属性(还是继承的?)，返回真假。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">'老张'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="keyword">if</span> (person.hasOwnProperty(key)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name</span></span><br></pre></td></tr></table></figure><p>以上总结From 『js标准参考教程』</p><hr><p>全局对象 global</p><p>在浏览器中，global为window</p><font style="color:white;background:mediumseagreen;padding:3px 6px;font-weight:bold;">window的属性分为两类</font><ul><li>ECMAScript规定 (标准化) parseInt | parseFloat</li><li>私有的(只有某些浏览器有，没有标准) <ul><li>alert 弹框提示</li><li>prompt 用户填写</li><li>confirm 确认</li><li>console 开发者</li><li>document （文档） DOM</li><li>history （浏览器） BOM</li></ul></li></ul><p>window的属性或方法，使用时可以省略window</p><p>window常用API</p><p>Window.Number() | String() | Boolean() | Object()</p><p>setTimeout (控制台打出的数字是指计时器序号)</p><p>var a = new Number(1); 这时 a的类型为object对象，而不是数字</p><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><blockquote><p><strong>Number()</strong></p></blockquote><p>直接声明1和new Number的区别</p><p>var n1 = 1;             数字1  栈内存</p><p>var n2 = new Number(1);  对象1  栈内存存地址，堆内存有各种属性方法和值</p><p>temp = new Number(n1); temp.toString();</p><p>然后把temp干掉，把temp.toString()返回表达式n1.toString()</p><p>js之父上述后 让n1简单数字 也可以用对象的属性和方法了</p><p>切记：临时对象temp会对抹杀，普通类型.xxx时 是引入了一个临时对象temp，这次用完立马抹杀</p><p>把简单类型当成对象使用时，都是转成了临时对象temp，用完立刻抹杀。</p><p>charAt(index) 获取index索引的字符</p><p>charCodeAt(index) index索引字符对应的Unicode编码</p><p>Var s = “abcd”; s0 = s.charAt(0); s1 = s.charCodeAt(0);</p><p>则s0为“a”,s1为97,s2=s.charCodeAt(0).toString(16),为97的十六进制数61</p><blockquote><p><strong>String()</strong></p></blockquote><blockquote><p><strong>trim</strong></p></blockquote><p><strong>裁剪左右两边的多余空格</strong></p><p>s1 = ‘ heell  ’</p><p>s1.trim() - s1 = ‘heell’</p><blockquote><p><strong>concat</strong></p></blockquote><p><strong>连接两个字符串</strong></p><p>s1 = ‘hello’; s2 = ‘world’;</p><p>console.log(s1.concat(s2));‘helloworld’</p><blockquote><p><strong>slice</strong></p></blockquote><p><strong>切片</strong></p><p>slice(start,num)，从索引start号开始，切出num片</p><p>s1 = “hello”</p><p>s1.slice(1,2) - “el”</p><blockquote><p><strong>replace</strong></p></blockquote><p><strong>替换</strong></p><p>s1.replace(‘e’,‘o’) - s1 = hollo (替换第一个？)</p><p>常用API可见MDN useful string methods</p><blockquote><p><strong>Boolean()</strong></p></blockquote><p>5个falsy值，0 | NaN | “” | null | undefined </p><p>其他全都是true，<font style="color:white;background:mediumseagreen;padding:3px 6px;font-weight:bold;">所有对象均为true</font>，包括false对象</p><p>⚠️注意：</p><p>对象和对象一般都不相等，因为他们地址不一样。即使指向的东西的值一样。</p><h2 id="JS里的原型"><a href="#JS里的原型" class="headerlink" title="JS里的原型"></a>JS里的原型</h2><h4 id="公用属性——原型"><a href="#公用属性——原型" class="headerlink" title="公用属性——原型"></a>公用属性——原型</h4><p>共用属性 toString | valueOf</p><p>为了减少内存浪费，不用每个对象里头都存一个toString</p><p>对象不存 toString和valueOf,但是可以调用</p><p>有一个隐藏的key，__proto__</p><p>__proto__ 存的是一个地址,指向那些共用属性 toString|valueOf </p><p>⚠️注意：</p><p>Number更复杂，__proto__中还套了一层__proto__，第二层__proto__才是指向的所有对象共有的属性，第一层__proto__是含有Number独有的属性</p><p>String和Boolean与Number类似，__proto__中还套了一层__proto__</p><p>结构像一棵树，Object的共有属性(Object.prototype)相当于树根，</p><p>Object.prototype-&gt; 对象的共有属性，也就是实例对象的__proto__对应的值</p><p>原型即共有属性的意思</p><p>var o1 = new Object();</p><p>o1.__proto__ === Object.prototype ✅ </p><p>其实对象也有两层__proto__,第二层__proto__为null(注意不是undefined)</p><p>o1.__proto__.__proto__ === null</p><p>var n1 = new Number(1);</p><p>n1.__proto__ === Number.prototype</p><p>n1.__proto__.__proto__ === Object.prototype</p><font style="color:white;background:mediumseagreen;padding:3px 6px;font-weight:bold;line-height:28px">某个实例访问属性，如果该实例的构造函数的prototype没有这个属性，就会往更下一层的__proto__(即Object的共有属性)去找，有的话就可调用成功，如果还是没有就返回undefined。</font><p>例如上文的 n1.hasOwnProperty就是往下一层的__proto__中找的属性，是对象才有的公共属性。</p><p>var __ = new __</p><p>var后的为对象，new后面的为函数对象</p><p>__proto__是对象的属性，prototype是函数的属性</p><p>对象.__proto__ === 函数.prototype</p><blockquote><p><strong>总结</strong></p><p><strong><font color="dared">对象.__proto__ == 该对象的构造函数.prototype</font></strong></p><p>__proto__是对象的属性，prototype是函数的属性</p><p><code>Object</code>| <code>String</code>| <code>Number</code>| <code>Boolean</code>| <code>Function</code>都是构造函数</p><p>否</p><p>Object.__proto__ === Function.__proto__</p><p>原型对象prototype的所有属性和方法，都能被实例对象共享。</p><p>原型对象的作用，就是定义所有实例对象共享的属性和方法。</p><p>实例对象的__proto__指向原型对象；</p><p>构造函数的prototype指向原型对象；</p><p>原型对象的constructor指向构造函数</p><p>(即Object===Object.prototype.constructor)</p><p>将一个东西当成函数，则用xx.prototype去获取他的原型</p><p>将一个东西当成对象，则用xx.__proto__去获取他的原型。</p><p>(functionxx.prototype是一个对象,obj.__proto__也是一个对象)</p><p>使用__proto__相当于使用一个访问器，</p><p>e.g. obj.__proto__ 相当于 Object.getPrototypeOf(obj)</p></blockquote> <font style="color:white;background:mediumseagreen;padding:3px 6px;font-weight:bold;line-height:2">特殊的Function</font><p>Fuction的构造函数也是Function，</p><p>Function.constructor === Function</p><blockquote><p>所以Function.__proto__ === Function.prototype</p><p>即Object.getPrototypeOf(Function)===Function.prototype</p></blockquote><p>全等号左侧的Function被当成对象，而右侧的Function被当做函数。</p><p>Function是Function的构造函数，</p><p>相当于var obj = new Object();</p><p>obj.__proto__===Object.prototype</p><p>Object是obj的构造函数</p><blockquote><p>Function.prototype.__proto__ = Object.prototype</p></blockquote><p>Function.prototype也是一个对象，对象的__proto__属性即对象的构造函数Object的prototype。</p><p>⚠️注意：</p><font color="dared"><strong>Object是所有所有对象的构造函数，而Function是所有所有函数对象(typeof xx为function)的构造函数。</strong></font><p>所以Object(Object是一个函数对象)的构造函数也是Function，则</p><blockquote><p>Object.__proto__ === Function.prototype </p><p>Object.__proto__ === Function.__proto__</p></blockquote><p>附上一张图总结：</p><p><img src="prototype.jpg" alt="prototype"></p><p>引自思否<a href="https://segmentfault.com/a/1190000014717972" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014717972</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊JS中的数据类型转换和内存图</title>
      <link href="/2018/10/18/%E8%81%8A%E8%81%8AJS%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%86%85%E5%AD%98%E5%9B%BE/"/>
      <url>/2018/10/18/%E8%81%8A%E8%81%8AJS%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%86%85%E5%AD%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="JS中的类型转换-amp-内存图-amp-GC-amp-深拷贝"><a href="#JS中的类型转换-amp-内存图-amp-GC-amp-深拷贝" class="headerlink" title="JS中的类型转换&amp;内存图&amp;GC&amp;深拷贝"></a>JS中的类型转换&amp;内存图&amp;GC&amp;深拷贝</h2><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><table><thead><tr><th>左👉右</th><th>number</th><th>string</th><th>boolean</th><th>null</th><th>undefined</th><th>object</th></tr></thead><tbody><tr><td><strong>number</strong></td><td></td><td>n.toString()<br>(6).toString()<br>或var num = 6;<br>num.toString()</td><td>Boolean(n)</td><td></td><td></td><td></td></tr><tr><td><strong>string</strong></td><td>Number(‘str’)</td><td></td><td>Boolean()</td><td></td><td></td><td></td></tr><tr><td><strong>boolean</strong></td><td>Number(true)</td><td>.toString()</td><td></td><td></td><td></td><td></td></tr><tr><td><strong>null</strong></td><td>Number()<br>转为0</td><td>无法用toString</td><td>Boolean()</td><td></td><td></td><td></td></tr><tr><td><strong>undefined</strong></td><td>Number()<br>转为NaN</td><td>无法用toString</td><td>Boolean()</td><td></td><td></td><td></td></tr><tr><td><strong>object</strong></td><td>对象和函数转为NaN，数组看情况</td><td>使用toString<br>‘[object Object]’</td><td>Boolean()</td><td></td><td></td></tr></tbody></table><p>🛵<strong>老司机妙招</strong></p><font style="color:white;background:mediumseagreen;padding:3px 6px;font-weight:bold;">快速转换成string类型：xx + ‘’==</font><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>+<span class="string">''</span> <span class="comment">//'1'</span></span><br><span class="line"><span class="literal">true</span>+<span class="string">''</span> <span class="comment">//'true'</span></span><br><span class="line"><span class="literal">undefined</span>+<span class="string">''</span> <span class="comment">//'undefined'</span></span><br><span class="line">(&#123;&#125;) + <span class="string">''</span> <span class="comment">//猜猜输出啥</span></span><br><span class="line">&#123;&#125; + <span class="string">''</span>   <span class="comment">//猜猜输出啥</span></span><br></pre></td></tr></table></figure><font style="color:white;background:mediumseagreen;padding:3px 6px;font-weight:bold;">快速转换成boolean类型：!!xx</font><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">!!<span class="literal">undefined</span> <span class="comment">//false</span></span><br><span class="line">!!<span class="literal">null</span> <span class="comment">//false</span></span><br><span class="line">!!<span class="number">6</span> <span class="comment">//true</span></span><br><span class="line">!!<span class="number">0</span> <span class="comment">//false</span></span><br><span class="line">!!<span class="string">'s'</span> <span class="comment">//true</span></span><br><span class="line">!!<span class="string">" "</span> <span class="comment">//空格字符串输出true</span></span><br><span class="line">!!<span class="string">''</span> <span class="comment">//猜猜输出啥</span></span><br><span class="line">!!&#123;&#125; <span class="comment">//猜猜输出啥</span></span><br><span class="line">!![] <span class="comment">//猜猜输出啥</span></span><br></pre></td></tr></table></figure><font style="color:white;background:mediumseagreen;padding:3px 6px;font-weight:bold;">快速转换成number类型：</font><ul><li><font style="color:white;background:mediumseagreen;padding:3px 6px;font-weight:bold;">xx - 0</font></li><li><font style="color:white;background:mediumseagreen;padding:3px 6px;font-weight:bold;">+xx</font></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+<span class="string">'s'</span><span class="comment">//NaN</span></span><br><span class="line">+<span class="string">'12'</span><span class="comment">//12</span></span><br><span class="line">+<span class="string">'1s'</span><span class="comment">//NaN</span></span><br><span class="line">+[]<span class="comment">//猜一猜</span></span><br><span class="line">+[<span class="number">123</span>]<span class="comment">//123</span></span><br><span class="line">+[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]<span class="comment">//NaN</span></span><br><span class="line">+&#123;&#125;<span class="comment">//猜一猜</span></span><br><span class="line">+<span class="literal">null</span><span class="comment">//猜一猜</span></span><br><span class="line">+<span class="literal">undefined</span><span class="comment">//猜一猜</span></span><br></pre></td></tr></table></figure><h5 id="转换方法总结"><a href="#转换方法总结" class="headerlink" title="转换方法总结"></a>转换方法总结</h5><blockquote><p><strong>转换为字符串的方法</strong></p></blockquote><ul><li><p>String(x)</p></li><li><p>x.toString()</p></li><li><p><strong>区别</strong></p><ul><li><p>.toString()不可用于null和undefined而String()可以。</p></li><li><p><code>注：</code>数字或对象使用toString方法需要加上括号，否则报错</p><p>666.toString()❌ (666).toString() ✔</p><p>{}.toString() ❌ ({}).toString() ✔</p></li><li><p>.toString可支持将数字转为不同进制字符串，例如(2).toString(2)//“10”</p><p>可支持.toString(2)|.toString(8)|.toString(10)括号内不写默认为10|.toString(16)</p></li></ul></li><li><p>x+‘’</p></li></ul><blockquote><p><strong>转换为数字的方法</strong></p></blockquote><ul><li>Number(xx)</li><li>parseInt(xx)</li><li>parseFloat(xx)</li><li>xx - 0</li><li>+xx</li></ul><p>❗ <strong>注意ParseInt</strong></p><p>完整写法是parseInt(value,radix)，value为要被解析的值，radix为基数。</p><blockquote><font color="darkorenge">parseInt会(从左到右)从第一个字符开始解析，直到碰到了无法解析为数字的东西(如unicode字母等)，前面的解析出来多少是多少，打印出多少。</font><p>例如：</p><p>parseInt(‘0b110’) //输出0</p><p>parseInt([1,2,3]) //输出1</p></blockquote><p>含义是将参数value看作radix进制数，返回十进制数值。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123'</span>, <span class="number">5</span>) <span class="comment">// 将'123'看作5进制数，返回十进制数38 =&gt; 1*5^2 + 2*5^1 + 3*5^0 = 38</span></span><br></pre></td></tr></table></figure><font style="color:white;background:mediumseagreen;padding:3px 6px;font-weight:bold;">易错点</font><p>先回顾下二进制、八进制、十六进制数表示：</p><blockquote><p><font color="deeppink"><strong>0b开头代表二进制</strong></font> <strong>|</strong> <font color="deeppink"><strong>0开头代表八进制</strong></font> <strong>|</strong> <font color="deeppink"><strong>0x开头代表十六进制</strong></font> (字母大小写均可)</p></blockquote><p>在没有指定基数radix或者基数为<code>0</code>时，有以下处理</p><ul><li><p>当参数value为<font color="darkorenge"><strong>数字</strong></font>时：</p><ul><li>以0b开头，则基数是2(二进制)</li><li>以0开头，则基数是8(八进制)</li><li>以0x开头，则基数是16(十六进制)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">017</span>) 相当于<span class="built_in">parseInt</span>(<span class="number">017</span>,<span class="number">10</span>)|<span class="built_in">parseInt</span>(<span class="number">017</span>,<span class="number">0</span>)</span><br><span class="line">也相当于直接在浏览器控制台输入 <span class="number">017</span> 得出一个数值</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">017</span>) <span class="comment">//15 , 1*8^1+7*8^0 = 15</span></span><br><span class="line"><span class="number">017</span> <span class="comment">//15 , 浏览器将其视为了八进制数，所以转换成十进制数后得到15</span></span><br><span class="line"><span class="number">0789</span> <span class="comment">//789,由于到达了8，浏览器会智能地将它视为十进制数，输出789</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">017</span>,<span class="number">8</span>) <span class="comment">//13,因为浏览器自动将017转为15,所以其实是parseInt(15,8),得到13</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">17</span>,<span class="number">8</span>) <span class="comment">//15,因为没有0开头,不知道他是八进制数，所以用给的radix参数来当作8进制数处理</span></span><br><span class="line">  <span class="comment">//即 1*8^1+7*8^0 = 15 ，相当于parseInt(017)</span></span><br></pre></td></tr></table></figure></li><li><p>当参数value为<font color="darkorenge"><strong>字符串</strong></font>时：</p><ul><li>以0b开头，并不会被识别为二进制，而是将b当为字符，所以解析到b之前中断，输出0</li><li>以0开头，<strong>基数是10</strong>(十进制)或8(八进制)，ES5规定为10，但可能有的浏览器仍为8,一般用10</li><li>以0x开头，则基数是16(十六进制)</li><li>其他任何开头视为基数10(十进制)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0b111'</span>) <span class="comment">//输出0</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0789'</span>)  <span class="comment">//789,视为十进制，若为八进制是不会出现8和9的</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0789'</span>,<span class="number">8</span>) <span class="comment">//7,浏览器自动将'0789'转为了789,只能解析出小于8的，所以是7</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0x178'</span>)  <span class="comment">//376,1*16^2+7*16+8*1=376，相当于parseInt('0x178',16)</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0x178'</span>,<span class="number">10</span>) <span class="comment">//0，若视为其他进制，则x越不过去，解析到x前停下，所以是0</span></span><br><span class="line">傻傻分不清楚：</span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0x011'</span>,<span class="number">16</span>)  <span class="comment">//17,1*16^1+1*16^0=17</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x011</span>,<span class="number">16</span>)   <span class="comment">//23 , 0x011自动被转为了17,所以是parseInt(17,16),1*16+7*1=23</span></span><br></pre></td></tr></table></figure></li></ul><p>有很多坑，具体可以看MDN资料：</p><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt</a></p></blockquote><blockquote><p><strong>转换为布尔值的方法</strong></p></blockquote><ul><li>Boolean(x)</li><li>!!x</li></ul><font style="color:white;background:mediumseagreen;padding:3px 6px;font-weight:bold;">记忆</font><p>只有0|NaN|‘’|undefined|null 是<code>5</code>个falsy值，转成boolean为false，其他<code>所有</code>都会转成true</p><p><code>所有对象</code>转为boolean都为true，包括空对象、空数组、空函数等</p><font style="color:white;background:mediumseagreen;padding:3px 6px;font-weight:bold;">注意</font><p>对象中</p><p>var obj = {null:0,undefined:0}</p><p>obj[null]==obj[‘null’]\==obj.null //都打印出0，null自动转换为了‘null’</p><p>obj[undefined]==obj[‘undefined’]\==obj.undefined//都打出0，undefined自动转成了‘undefined’</p><h3 id="内存图"><a href="#内存图" class="headerlink" title="内存图"></a>内存图</h3><p>js内存分配</p><p>js引擎将内存分成两大块</p><p>代码区：存代码 a </p><p>数据区：‘1’ 2 {}</p><p>栈内存(stack)和堆内存(heap)</p><p>栈内存可以存基本类型的值或者对应堆内存的地址</p><p>堆内存可以存复杂类型的值(如对象)，对象属性的值又可以是地址，这个地址再对应heap中的地址所对应的内容。</p><p>js中数字是以64位浮点数存的</p><p>64位(2^64^)可以表示目前市面上任意大小内存的任一个地址</p><p>js存字符，每个字符16位</p><p>数字64，字符16(后来更新了)</p><p>var a = 2</p><p>先进行变量提升</p><p>若用栈内存按顺序存对象object，一旦要改对象的属性或者新增属性，就需要把之前对象后面的数据往后挪，特别的麻烦。所以只存一个地址，例如是100，100对应堆内存中的100号内存位置，这儿存着整个对象。</p><p>然后如果要改对象属性或者给对象加属性，直接根据地址100找到堆内存对应位置，然后修改或添加即可。</p><p>新加对象的话，就在栈内存新存一个地址，例如是200。则地址100对应对象obj1，地址200对应对象obj2。</p><blockquote><p>若写一个对象赋值语句obj2 = obj1</p><p>然后对象的赋值实际上是将obj1对应的地址赋到了obj2那个位置，然后两个栈内存位置存的地址都是100了，obj1和obj2都指向了100。并没有多出的拷贝。见下图：</p><p><img src="memorypic.png" alt="memorypic"></p></blockquote><p>不同数据类型的存储</p><ul><li>简单数据类型<ul><li>直接存在Stack栈内存  num|str|symbol|bool|null|undefined</li></ul></li><li>复杂数据类型<ul><li>把Heap堆内存地址存到Stack栈，内容存在Heap堆内存中  object对象</li></ul></li></ul><blockquote><p>变量跟对象的关系是引用关系，没有直接存你，而是存的你的地址。</p><p>var obj={name:frank}  //变量obj是对象的引用，obj存的是对象的地址而不是对象的值本身</p></blockquote><p>❗ <strong>切记</strong></p><p>赋值，等于号只做一件事情，就是把等于号右边的东西存到等于号左边的东西里头。</p><p>赋值必须先确定等号右边的值，然后再开始赋值。</p><p>例子：</p><p>var a = {name:‘a’};</p><p>b = a;</p><p>b = {name:‘b’};</p><p>console.log(a.name); //画内存图</p><p>将新对象赋给b 改的是b存的地址，而不会改heap中原有的内容</p><p>将新数字(或其他基本类型)赋给b 则b位置存的地址会被新的值覆盖掉</p><blockquote><p>几个题目例子，用内存图弄清对象的赋值</p><p><code>基本类型之间的赋值</code></p><p><img src="copy1.png" alt="copy1"></p><p><code>直接赋值给对象</code></p><p><img src="copy2.png" alt="copy2"></p><p><code>赋值给对象的属性</code></p><p><img src="copy3.png" alt="copy3"></p><p><code>将基本类型值赋值给原来的对象</code></p><p><img src="copy4.png" alt="copy4"></p></blockquote><p>var a ={};a.self=a; a.self.self.self.self可以取到么？ //可以</p><p>其实heap里头只有一个对象，从stack找到heap，然后self的值addr33又找到了heap中33号地址位置的东西(就是自己)，然后不停地调自己。</p><p><img src="objself.png" alt="objself"></p><p>若是var a = {self:a};a.self.self.self //就会报错，</p><p>因为赋值操作必须先确定右边的值，而第一次右边的值中的a是undefined 所以 a = {self:undefined};</p><p>再来一次a = {self:a};就会变成 a = {self:{self:undefined}},再打一次就会再嵌套一层，不打就停在那一层。</p><p>❗ <strong>坑</strong>🕳</p><p>alert会调用toString()方法</p><p>a.x = a ={n:2};</p><p>先确定a，而不是从右往左算到最后才确定a，一开始就确定好了a，然后a={n:2}时会再把a存的地址改了</p><blockquote><p>多复习回顾几次:</p><p><a href="https://xiedaimala.com/tasks/61db0dcc-71d4-4f0c-822d-5f24ff0dd128/video_tutorials/22579fe7-206c-411f-a8e1-5786501bf481" target="_blank" rel="noopener">https://xiedaimala.com/tasks/61db0dcc-71d4-4f0c-822d-5f24ff0dd128/video_tutorials/22579fe7-206c-411f-a8e1-5786501bf481</a></p></blockquote><hr><h3 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h3><h5 id="GC-Garbage-Collecation"><a href="#GC-Garbage-Collecation" class="headerlink" title="GC:Garbage Collecation"></a>GC:Garbage Collecation</h5><blockquote><p><strong>🖊核心</strong></p><p>如果一个对象没有被引用，他就是垃圾，将会被回收。</p></blockquote><p>有人罩着就不回收，没人罩着就回收。</p><p><img src="trash.png" alt="trash"></p><p>若页面关闭了，document的click事件对应的function全成了垃圾。</p><p>但ie有bug，不会回收，可加以下代码解决</p><p>window.onunload = function(){document.body.onclick = null;}</p><p>题目1</p><p>hard1</p><p><img src="hard1.png" alt="hard1"></p><p>题目2</p><p>var fn = function(){}</p><p>document.body.onclick = fn</p><p>fn = null</p><p>问function是不是垃圾</p><p><img src="hard2.png" alt="hard2"></p><p>var fn = function(){}</p><p>document.body.onclick = fn</p><p>fn = null</p><p>document.body.onclick = null</p><p>问function是不是垃圾</p><p><img src="hard3.png" alt="hard3"></p><h3 id="深拷贝-VS-浅拷贝"><a href="#深拷贝-VS-浅拷贝" class="headerlink" title="深拷贝 VS 浅拷贝"></a>深拷贝 VS 浅拷贝</h3><blockquote><p>深拷贝</p></blockquote><p>var a = 1;</p><p>var b = a;</p><p>b变不影响a，深拷贝</p><p>基本类型的赋值，为深拷贝</p><blockquote><p>浅拷贝</p></blockquote><p>var a = {name:‘a’}</p><p>var b = a</p><p>b.name = ‘b’</p><p>a.name //也是b</p><p>b变a也变，浅拷贝</p><p>对象的深拷贝，见下图</p><p><img src="deepcopy.png" alt="deepcopy"></p><p>深拷贝如何实现，请听下回分解</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈JS中的数据</title>
      <link href="/2018/10/17/%E8%B0%88%E8%B0%88JS%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/10/17/%E8%B0%88%E8%B0%88JS%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="JS里的数据"><a href="#JS里的数据" class="headerlink" title="JS里的数据"></a>JS里的数据</h2><h3 id="JS黑历史"><a href="#JS黑历史" class="headerlink" title="JS黑历史"></a>JS黑历史</h3><p>1991 李爵士 www</p><p>1992 李爵士同事 CSS</p><p>1993 W3C</p><p>1995 网景 Netscape =&gt; Navigator</p><p>Branden Eich JS之父，设计了js初版 Mocha</p><p>改名Mocha=&gt;LiveScript=&gt;JavaScript</p><p>网景和Sun达成协议，出品一门脚本语言。</p><p>几年后 Unicode和UTF-8发布  (JS在这之前就出现了，所以它的编码有bug)</p><p>1996 MS-&gt;IE =&gt; JScript 想抢占市场</p><p>后来 浏览器市场占有 ms打败了网景</p><p>网景开源浏览器 =&gt; Firefox 项目</p><p>​    IE5.5 MS推出JS发请求功能</p><p>2004 Gmail，网页上的程序 JS被正式认为是一门编程语言了(可以开发项目)</p><p>网景为了对抗微软的脚本，向ECMA(欧洲计算机制造协会)申报标准</p><p>标准名为 ECMAScript(因为javascript商标已经被注册了，不可用)</p><p>JS的一些缺点：全局变量(没有模块化)、标准库(内置代码少) | ES3以及之前</p><p>ECMAScript5 做了个小升级 步子比较小</p><p>ECMAScript6 做了比较给力的升级 可以视为现代编程语言了</p><p>很多来源于Rails社区的CoffeeScript社区</p><blockquote><p><strong>JS之父对JS的评价</strong></p><p>原创之处并不优秀，</p><p>优秀之处并非原创！</p></blockquote><p>目前JS每年一更 </p><p>ES7 | ES8 | ES Next</p><blockquote><p>ES5新特性汇总：<a href="https://zhuanlan.zhihu.com/p/24336831?refer=study-fe" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24336831?refer=study-fe</a></p><p>ES6新特性汇总：<a href="https://zhuanlan.zhihu.com/p/24570791" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24570791</a></p></blockquote><p><code>JS学习路径推荐</code></p><p>先学核心ES3，小升级到ES5，再学习ES6(稍微要多花点时间精力)</p><p>没有纳入规范的js语法，可能就先用上了，例如Chrome支持了y1、然后firefox也支持了y1’、IE也支持了y1’’</p><p>ECMA一看大家都支持了，就把他纳入规范。</p><p>或者例如Chrome支持x1，firefox不支持，可以通过Babel来转义。</p><hr><h3 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h3><p><strong>7种数据类型</strong></p><ul><li>number 数字</li><li>string 字符串</li><li>boolean 布尔值</li><li>object 对象</li><li>null</li><li>undefined</li><li>symbol 符号</li></ul><p>注：array和function并不是数据类型，他们都属于object对象</p><blockquote><p>object对象为复杂类型，其他6种都为基本类型(简单类型)</p></blockquote><h5 id="number数字"><a href="#number数字" class="headerlink" title="number数字"></a>number数字</h5><p>十进制数表示：</p><p>1 | .1 | 1.23e2（代表1.23*10^2^)</p><p>二进制：0b开头，e.g 0b11代表3</p><p>八进制：0开头， e.g 011代表9</p><p>十六进制：0x开头，e.g 0x11代表17</p><h5 id="string字符串"><a href="#string字符串" class="headerlink" title="string字符串"></a>string字符串</h5><blockquote><p>由于发布在unicode和utf-8之前的历史原因，JS只能支持到两个字节的unicode字符</p></blockquote><p>空字符串：‘’ | “” 长度为0</p><p>空格字符串：‘ ’ | “ ” 长度为1</p><p>回车也占长度</p><p>例如：</p><p>var str=`12345<br>67890`</p><p>str长度是11，因为有回车，输出是<br>12345<br>67890</p><blockquote><p><strong><em>转义</em></strong></p><p>符号前加\ 意为这个符号不是结束，而是我想显示出来的符号<br>转义符不占长度</p><p>想显示一个单引号的方法：</p><p>var a = “‘”<br>var a = ‘\‘’</p><p>多行字符串(抄袭命令行，\再加回车来表示换行)</p><p>var str = ‘a\     //此处\代表不是结束<br>​           b’</p><p>常用转义：<br><code>\0</code> ：null（<code>\u0000</code>）</p><p><code>\b</code> ：后退键（<code>\u0008</code>）</p><p><code>\f</code> ：换页符（<code>\u000C</code>）</p><p><code>\n</code> ：换行符（<code>\u000A</code>）</p><p><code>\r</code> ：回车键（<code>\u000D</code>）</p><p><code>\t</code> ：制表符（<code>\u0009</code>）</p><p><code>\v</code> ：垂直制表符（<code>\u000B</code>）</p><p><code>\&#39;</code> ：单引号（<code>\u0027</code>）</p><p><code>\&quot;</code> ：双引号（<code>\u0022</code>）</p><p><code>\\</code> ：反斜杠（<code>\u005C</code>）<br>\加空格 转义 为空格</p></blockquote><h5 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h5><p>两个值 true | false</p><p>a&amp;&amp;b 两个为真则为真，其中一个为假则为假</p><p>a||b 两个为假则为假，其中一个为真则为真</p><h5 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h5><font color="white" style="font-weight:bold;background:#4EEE94">&nbsp;区别&nbsp;</font><ul><li>【语法】变量未赋值，则为undefined 不是null。</li><li>【惯例】<ul><li>有一个object对象，现在不想赋值。推荐可初始化为null。 </li><li>有一个非object对象，现在不想赋值。推荐可初始化为undefined。</li></ul></li></ul><h5 id="对象object"><a href="#对象object" class="headerlink" title="对象object"></a>对象object</h5><p>对象是复杂类型，由基本类型组成。</p><p>简单类型的组合。</p><h6 id="创建对象方式"><a href="#创建对象方式" class="headerlink" title="创建对象方式"></a>创建对象方式</h6><ul><li>var ob = {};</li><li>var ob2 = new Object();</li><li>var ob3 = Object.create(Object.prototype);</li></ul><h6 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h6><p>person[‘name’]  <strong>一定要有单引号，否则被视为变量名</strong></p><p>person.name  <strong>key符合标识符规范的时候才可以这么用，切记!</strong></p><p>❗ <strong>注意</strong></p><p>空字符串也可以作为对象的key，使用方式为person[‘’]=‘superman’</p><p>如果key不加单引号，就必须遵循标识符规则(不可以数字开头，中间无空格，必须符合变量名规则)</p><blockquote><ul><li>第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（<code>$</code>）和下划线（<code>_</code>）。</li><li>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字<code>0-9</code>。</li></ul></blockquote><p>所以9a不可以作为key，但是‘9a’可以作为key。使用person[‘9a’]</p><blockquote><p>对象的键为字符串类型，将其他类型作为key，会转为字符串类型。</p></blockquote><p>对象自己可以作为某个key的value，例如：</p><p>var person = {age:18,self:person}，但是第一次定义后打印person是{age:18,self:undefined}</p><p>再定义一次var person = {age:18,self:person}，</p><p>然后打印就成了{age:18,self:{age:18,self:undefined}}，一次次的递归。</p><p>对象中的方法</p><p>delete person[‘name’] //把key和value都删除了，返回true说明删除成功</p><p>‘name’ in person //成false了</p><p>person.name = undefined //相当于只是把’name’对应的value删除了，key还在。</p><blockquote><p>for…in…</p><p>可以遍历对象中的key，但注意输出的key是随即顺序不是固定顺序</p><p>for(var key in person){console.log(key);}</p><p>遍历对象中的value则用以下写法：</p><p>for(var key in person){console.log(person[key]);}</p><p>//注意不是person.key，因为key是获取到的字符串，person.key相当于person[‘key’]肯定是错误的</p><p>一起打印使用:</p><p>console.log(key,person[key])</p></blockquote><p>typeof 返回类型名字符串</p><p>缺陷：</p><ol><li>typeof null //‘object’</li><li>typeof function //‘function’</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS布局-居中小贴士</title>
      <link href="/2018/09/11/CSS%E5%B8%83%E5%B1%80-%E5%B1%85%E4%B8%AD%E5%B0%8F%E8%B4%B4%E5%A3%AB/"/>
      <url>/2018/09/11/CSS%E5%B8%83%E5%B1%80-%E5%B1%85%E4%B8%AD%E5%B0%8F%E8%B4%B4%E5%A3%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="CSS布局小贴士"><a href="#CSS布局小贴士" class="headerlink" title="CSS布局小贴士"></a>CSS布局小贴士</h3><p><strong>常见简单布局:左右布局，左中右布局。</strong></p><h4 id="左右布局实现"><a href="#左右布局实现" class="headerlink" title="左右布局实现"></a>左右布局实现</h4><ul><li><blockquote><p><strong>使用浮动float</strong></p></blockquote><p>可将左部分区域和右部分区域的float属性都设置为left，然后使用margin来调节两区域之间的间距。</p><p>或者将左部分区域设置float:left，右部分区域float:right，用margin调节两区域间距。</p><p><code>注意：使用float会造成元素脱标，要注意宽度的设置，要给父元素清除浮动</code></p></li><li><blockquote><p><strong>使用inline-block</strong></p></blockquote><p>将左右部分区域display属性均设置为inline-block，然后左右区域即可在同一行显示，达到左右布局效果。</p><p><code>注意：inline-block元素之间会因为换行导致有空隙，可用margin来调节间距。</code></p></li></ul><ul><li><blockquote><p><strong>使用flex布局</strong></p></blockquote><p>将父容器display属性设置为flex，justify-content可以调节多种排布方式，居于两侧、居中、开头对齐、末尾对齐等。</p><p>可以用flex-basis来设置左右区域的具体宽度值，也可用flex-grow来设置左右区域占父容器空间的比值。</p></li></ul><h3 id="CSS居中小贴士"><a href="#CSS居中小贴士" class="headerlink" title="CSS居中小贴士"></a>CSS居中小贴士</h3><h4 id="左中右布局实现"><a href="#左中右布局实现" class="headerlink" title="左中右布局实现"></a>左中右布局实现</h4><p><strong>和左右布局一样，可采用上述三种方式来实现</strong></p><hr><ul><li>使用float方式来布局</li><li>使用inline-block方式来布局</li><li>使用flex弹性布局方式</li></ul><h4 id="水平居中实现"><a href="#水平居中实现" class="headerlink" title="水平居中实现"></a>水平居中实现</h4><blockquote><p><strong>行内元素的水平居中</strong></p></blockquote><ul><li>给父元素设置text-align:center;</li><li>给父元素设置display:flex;justify-content:center;</li></ul><blockquote><p><strong>块级元素的水平居中</strong></p></blockquote><ul><li>元素宽度确定时，给元素设置margin:0 auto;</li><li>元素宽度不确定时，<ul><li>给父元素设置display:flex;justify-content:center;</li><li>给父元素设置display:flex;子元素设置margin:0 auto;</li><li>给父元素设置display:grid;justify-content:center;</li><li>给父元素设置display:grid;子元素设置margin:0 auto;</li></ul></li></ul><h4 id="垂直居中实现"><a href="#垂直居中实现" class="headerlink" title="垂直居中实现"></a>垂直居中实现</h4><blockquote><p><strong>行内元素的垂直居中</strong></p></blockquote><ul><li>设置父元素的高度height与行高line-height一致，则父元素内的行内子元素会垂直居中显示</li><li>给父元素设置display:flex;flex-direction:column;justify-content:center;</li><li>给父元素设置display:flex;align-items:center;</li><li>给父元素设置display:flex;子元素设置margin:auto 0;</li><li>给父元素设置display:grid;align-content:center;</li><li>给父元素设置display:grid;子元素设置margin:auto 0;</li></ul><blockquote><p><strong>块级元素的垂直居中</strong></p></blockquote><p><code>💡 flex布局和grid布局的方法对行内元素或块级元素都适用</code></p><ul><li><p>给父元素设置display:flex;flex-direction:column;justify-content:center;</p></li><li><p>给父元素设置display:flex;align-items:center;</p></li><li><p>给父元素设置display:flex;子元素设置margin:auto 0;</p></li><li><p>给父元素设置display:grid;align-content:center;</p></li><li><p>给父元素设置display:grid;子元素设置margin:auto 0;</p></li><li><p>元素高度确定时，</p><ul><li><p>父元素设置相对定位，子元素设置绝对定位，子元素top:50%;margin-top:-元素高度/2;</p></li><li><p>子元素设置相对定位，子元素top:50%;margin-top:-元素高度/2;</p></li><li><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span><span class="selector-pseudo">:before</span>,<span class="selector-class">.father</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">            <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">            <span class="attribute">display</span>:block;</span><br><span class="line">            <span class="attribute">height</span>: (父元素高度-子元素高度)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>元素高度不确定时，</p><ul><li>父元素设置相对定位，子元素设置绝对定位，子元素top:50%;translateY(-50%)/translate(0,-50%)</li><li>子元素设置相对定位，子元素top:50%;translateY(-50%)/translate(0,-50%)</li></ul></li></ul><h4 id="水平垂直居中万用大法"><a href="#水平垂直居中万用大法" class="headerlink" title="水平垂直居中万用大法"></a>水平垂直居中万用大法</h4><p><code>行内元素、块级元素均可</code> <strong>flex布局大法和grid布局大法</strong></p><ul><li>给父元素设置display:flex;justify-content:center;align-items:center;</li><li>给父元素设置display:flex;给子元素设置<strong>margin:auto;</strong></li><li>给父元素设置display:grid;justify-content:center;align-content:center;</li><li>给父元素设置display:grid;给子元素设置<strong>margin:auto;</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 布局技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML标签那些事儿(下)</title>
      <link href="/2018/09/05/HTML%E6%A0%87%E7%AD%BE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF(%E4%B8%8B)/"/>
      <url>/2018/09/05/HTML%E6%A0%87%E7%AD%BE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF(%E4%B8%8B)/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML标签那些事儿-下"><a href="#HTML标签那些事儿-下" class="headerlink" title="HTML标签那些事儿(下)"></a>HTML标签那些事儿(下)</h2><blockquote><p>故事上篇，已经大致介绍了大部分HTML标签的用途。</p><p>故事下篇，我们来介绍下常用标签和常用用法，以及一些小tips。</p></blockquote><blockquote><p>常用标签&amp;用法</p></blockquote><p><code>iframe标签</code></p><p>属性：frameborder | src(嵌套页面的url地址) | name | scrolling</p><p>name常配合a标签使用</p><p><code>a标签</code></p><ul><li><strong>a标签<code>target</code>属性</strong></li></ul><table><thead><tr><th style="text-align:center">值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">_blank</td><td style="text-align:center">在新窗口中打开被链接文档。</td></tr><tr><td style="text-align:center">_self</td><td style="text-align:center">默认值。在相同的框架中打开被链接文档。</td></tr><tr><td style="text-align:center">_top</td><td style="text-align:center">在最大的整个浏览器窗口中(即最外层的祖先框架集)打开被链接文档。</td></tr><tr><td style="text-align:center">_parent</td><td style="text-align:center">在父框架集中打开被链接文档。(a自己所在框架集中的父框架集)</td></tr><tr><td style="text-align:center"><em>framename</em></td><td style="text-align:center">在指定的框架中打开被链接文档。</td></tr></tbody></table><p>💡 framename用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe name=&quot;baidu_iframe&quot; src=&quot;#&quot; frameborder=0 width=100% height=500px&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;baidu_iframe&quot;&gt;iframe百度&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>此栗子中，点击a链接，会在框架中打开百度首页。iframe的name需配合a链接使用。</p><p><code>注</code></p><p>若框架名字为属性关键字时，点击a链接<strong>关键字属性生效</strong>，franmename不生效。</p><ul><li><strong>a标签<code>download</code>属性</strong></li></ul><p>a标签链接到网页|文本|图片，加上该属性后都会触发强制下载</p><p>download还可以指定下载文件的名字/后缀信息，不指定则为原本名称。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.baidu.com"</span> <span class="attr">download</span>&gt;</span>下载<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://js.jirengu.com/images/dave.min.svg"</span> <span class="attr">download</span>=<span class="string">"jsbin.svg"</span>&gt;</span>下载并重命名<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>想让浏览器以下载形式处理该请求，两种方法</p><ol><li>http响应中的Content-Type: application/octet-stream    </li><li>给a链接加上download属性，指定强制下载</li></ol><ul><li><p><strong>a标签<code>href</code>属性</strong></p><ul><li><p>🌀 <strong>注意</strong></p><p>\&lt;a href=”qq.com”>QQ\&lt;/a></p><p>qq.com是相对路径，并不是URL，这种写法无法访问qq官网，URL包括协议-域名-端口号-路径-查询参数-锚点等</p><p>至少包含协议-域名才能正常定位过去，<a href="http://qq.com" target="_blank" rel="noopener">http://qq.com</a> 才是URL。</p><p>\&lt;a href=”//qq.com”>QQ\&lt;/a></p><p>//无协议，以当前协议的方式访问，即a所在的html的协议</p></li></ul><hr><ul><li><p>href可以写<code>锚点</code>(页面内跳转)，打开代表html路径#锚点，不会发起请求 </p><p>路径是127.0.0.1/index.html</p><p>\&lt;a href=”#id1”>QQ\&lt;/a> 即127.0.0.1/index.html#id1</p></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">href还可以写`查询参数`(一定不能漏了`?`，打开代表html路径查询参数(紧跟在路径后)</span><br><span class="line"></span><br><span class="line">打开时会发起一个get请求</span><br><span class="line"></span><br><span class="line">\&lt;a href=&quot;?name=superman&quot;\&gt;QQ\&lt;/a\&gt; 即127.0.0.1/index.html?name=superman</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">href还可以写`伪协议`，javascript:xxxxx;</span><br><span class="line"></span><br><span class="line">\&lt;a href=&quot;javascript:alert(helloQQ)&quot;\&gt;QQ\&lt;/a\&gt; 打开后会执行js代码，弹框显示helloQQ</span><br></pre></td></tr></table></figure><hr><ul><li><p>🔨<code>一个小技巧</code> <strong>完美实现点击a链接但是无任何反应</strong></p><p>\&lt;a href=”javascript:;”>QQ\&lt;/a> (不能漏掉分号，否则会报错，加分号代表什么都不做)</p><p>\&lt;a href=”javascript:void(0)”>QQ\&lt;/a> (作用同以上写法，但要小心)</p><p>\&lt;a href=”##”>QQ\&lt;/a> (也可写###,#默认为#top,但##/###浏览器不认识,所以默认不处理)</p><blockquote><p><a href="https://www.cnblogs.com/lfan192517/p/7242998.html" target="_blank" rel="noopener">https://www.cnblogs.com/lfan192517/p/7242998.html</a> 2、3方法引自此，细节可看文章</p></blockquote><p>以下写法都有瑕疵</p><ol><li>\&lt;a href=”#”>QQ\&lt;/a> 页面内跳转不会发请求，但是点击会跳到顶部，因为#默认代表#top</li><li>\&lt;a href=””>QQ\&lt;/a> 默认跳转到自身，会刷新页面而且发送get请求</li></ol></li></ul><blockquote><p>总结<code>href</code>可写形式</p></blockquote><ul><li>//qq.com 无协议</li><li>#xxx <strong>|</strong> ?name=superman <strong>|</strong> ./xxx.html</li><li>javascript:alert(1); <strong>|</strong> javascript:; <strong>|</strong> javascript:void(0);</li></ul><p><code>form标签</code></p><p>form跳转页面是HTTP POST请求，a标签跳转页面是HTTP GET请求</p><p>input的name很重要，写了name提交后服务器才能得到想要的信息</p><p>action属性指定请求路径</p><p><code>相对路径 | 绝对路径 | 查询参数 | #</code></p><p>#代表提交数据到本页</p><p>method指定请求方式</p><p><code>GET | POST</code></p><ul><li><p>form表单中没有input:submit按钮的话 无法提交这个form 除非用js</p></li><li><p>form表单设置method参数则默认为get请求，实际使用一般都用POST方式。</p></li><li><p>form表单提交后可在浏览器Form Data查看请求的第4部分内容</p></li><li><p>form的method只支持post和get，</p><p>当使用get时填入表单的数据会作为查询参数(Query String Parameters)</p><p>当使用POST时填入表单的数据会作为Form Data(请求的第4部分的数据)</p></li><li><p>form标签action属性可以写查询参数，让post请求也带查询参数，但是无法让get请求带第4部分数据</p></li><li><p>当form表单中只有一个button标签<strong>且没声明type</strong>，则自动升级为type-submit；input-button不会升级</p></li><li><p>有target属性，规则<code>与a标签一模一样</code> _blank <strong>|</strong> _self <strong>|</strong> _parent <strong>|</strong> _top <strong>|</strong> frameName </p></li></ul><p><em>http协议支持POST和GET,file协议不支持POST和GET</em> </p><p><em>http协议，form data可以明文看到password,https协议会加密</em></p><p><code>input标签</code></p><ul><li><p>input type=“search”    搜索框专用，比text的右侧多了一个×</p><p>input type=“range”    滑块控件(水平滑动条)</p></li></ul><p>input标签配合label使用，可以实现点击文字直接定位或选中对应input的效果。</p><ol><li><p>label的for属性值得设置为input标签的id值</p></li><li><p>💡 label把input标签嵌套起来(如\&lt;label>\&lt;input type=”text”>\&lt;/label>)</p><p>，这时候他们就有了关联关系！</p></li></ol><p>input标签name属性的作用是：get方式请求时，提交后能看到这个input标签的值(作为查询参数中的key)，带有name才能看到，value会作为name的值</p><p><code>button标签</code></p><p>属性type取值 submit | button | reset</p><p>当form表单中只有一个button标签<strong>且没声明type=button</strong>，则自动升级为type-submit</p><p><code>textarea标签</code></p><p>textarea标签，style=resize:none;则无法拉动宽高。</p><p>实际上如果需要精确的宽高一般用css设置，而不时cols和rows属性。</p><p><code>table标签</code></p><p>表头为th，会加粗</p><p>可设定每列的宽度，可以不带单位，bgcolor设定列的颜色</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">clogroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">col</span> <span class="attr">width</span>=<span class="string">100</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">col</span> <span class="attr">width</span>=<span class="string">200</span> <span class="attr">bgcolor</span>=<span class="string">green</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">colgroup</span>&gt;</span></span><br></pre></td></tr></table></figure><p>thead、tbody、tfoot可以不写</p><p>💡 边框合并但不加粗，单元格边框没间隙的表格，css写法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line"><span class="attribute">border-collapse</span>: collapse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">td</span> &#123;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>div标签和span标签</code></p><p>分别为块元素和行内元素无语义标签，可用于任何需要的地方。</p><p>div常用来包含内容/做布局，span常套文字。</p><p><code>一些HTML5的新增语义化标签</code></p><p>header | footer | main | nav | article | section | aside</p><p>等，默认为块元素，若怕有的浏览器不支持，可再声明一次display:block;</p><p><code>一个HTML5全局属性</code></p><p>contenteditable:内容可编辑的</p><p>e.g </p><p>\&lt;p contenteditable=”true”>我是可编辑的\&lt;/p></p><p>\&lt;div contenteditable=”true”>我是可编辑的\&lt;/div></p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP相关姿势</title>
      <link href="/2018/09/04/HTTP%E7%9B%B8%E5%85%B3%E5%A7%BF%E5%8A%BF/"/>
      <url>/2018/09/04/HTTP%E7%9B%B8%E5%85%B3%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP相关姿势"><a href="#HTTP相关姿势" class="headerlink" title="HTTP相关姿势"></a>HTTP相关姿势</h1><p><code>HTTP 的作用就是指导浏览器和服务器如何进行沟通。</code></p><h2 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h2><p>curl命令是一个利用URL规则在命令行工作的文件传输工具。</p><p>支持文件的上传和下载。</p><table><thead><tr><th>常用命令</th><th>功能</th></tr></thead><tbody><tr><td>-X/–request</td><td>指定请求方式，GET/POST/PUT/PATCH/DELETE/HEAD/OPTIONS</td></tr><tr><td>-H/–header</td><td>自定义头信息传递给服务器</td></tr><tr><td>-d/–data</td><td>HTTP POST方式传送数据</td></tr><tr><td>-v/–verbose</td><td>详细输出，包含请求和响应的头部</td></tr><tr><td>-s/–silent</td><td>静默模式，不显示错误和进度</td></tr><tr><td>-O/</td><td>从远程下载文件到当前目录，保留原文件名</td></tr></tbody></table><p>命令使用举🌰</p><ul><li><p>curl -X POST <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a> </p><p>不带-X 默认为GET请求方式</p></li></ul><hr><ul><li>curl -X POST -H “superman285:xxx” <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></li></ul><hr><ul><li>curl -X POST -v -H “superman285:xxx” <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></li><li>curl -X POST -v -s -H “superman285:xxx” <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></li></ul><p>请求内容为</p><blockquote><p>> POST / HTTP/1.1<br>> Host: <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>> User-Agent: curl/7.59.0<br>> Accept: */*<br>> superman285:xxx</p><p>></p></blockquote><p>响应内容为</p><blockquote><p>&lt; HTTP/1.1 302 Found<br>&lt; Connection: Keep-Alive<br>&lt; Content-Length: 17931<br>&lt; Content-Type: text/html<br>&lt; Date: Mon, 03 Sep 2018 16:36:53 GMT<br>&lt; Etag: “54d97485-460b”</p><p>* Server bfe/1.0.8.18 is not blacklisted<br>&lt; Server: bfe/1.0.8.18<br>&lt;<br>网页html内容…</p></blockquote><hr><ul><li>curl -X POST -d “123456789” -v -s -H “superman285:xxx” <a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></li></ul><p>请求内容为</p><blockquote><p>> POST / HTTP/1.1<br>> Host: <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>> User-Agent: curl/7.59.0<br>> Accept: */*<br>> superman285:xxx</p><p>> Content-Length: 9</p><p>> Content-Type: application/x-www-form-urlencoded</p><p>></p><p>1234567890</p></blockquote><p>响应内容为</p><blockquote><p>&lt; HTTP/1.1 302 Found<br>&lt; Connection: Keep-Alive<br>&lt; Content-Length: 17931<br>&lt; Content-Type: text/html<br>&lt; Date: Mon, 03 Sep 2018 16:36:53 GMT<br>&lt; Etag: “54d97485-460b”</p><p>* Server bfe/1.0.8.18 is not blacklisted<br>&lt; Server: bfe/1.0.8.18<br>&lt;<br>网页html内容…</p></blockquote><hr><p>curl -O <a href="https://ss0.bdstatic.com/img/logo_baidu.com" target="_blank" rel="noopener">https://ss0.bdstatic.com/img/logo_baidu.com</a></p><hr><p>🌀 <strong>注意</strong></p><p>curl -s -v -H “superman285:666” <a href="https://xiedaimala.com/search?keyword=scss&amp;type=courses&amp;page=1" target="_blank" rel="noopener">https://xiedaimala.com/search?keyword=scss&amp;type=courses&amp;page=1</a></p><p>如果在命令行中输入这行命令，只能识别一个查询参数keyword=scss，解决方法：</p><ul><li>转义： <a href="https://xiedaimala.com/search?keyword=scss\&amp;type=courses\&amp;page=1" target="_blank" rel="noopener">https://xiedaimala.com/search?keyword=scss\&amp;type=courses\&amp;page=1</a></li><li>加双引号：“<a href="https://xiedaimala.com/search?keyword=scss&amp;type=courses&amp;page=1”" target="_blank" rel="noopener">https://xiedaimala.com/search?keyword=scss&amp;type=courses&amp;page=1”</a></li></ul><blockquote><p>参考博客园-mofy文章 <a href="https://www.cnblogs.com/z-books/p/6228284.html" target="_blank" rel="noopener">https://www.cnblogs.com/z-books/p/6228284.html</a></p></blockquote><h2 id="请求与响应的构成"><a href="#请求与响应的构成" class="headerlink" title="请求与响应的构成"></a>请求与响应的构成</h2><hr><blockquote><p>HTTP请求和HTTP响应都包含4部分</p></blockquote><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><ol><li>请求方法 路径 协议/版本号</li><li>请求头</li><li>空行</li><li>请求数据正文</li></ol><h3 id="请求具体格式"><a href="#请求具体格式" class="headerlink" title="请求具体格式"></a>请求具体格式</h3><ul><li>第1部分：动词 路径 协议/版本号</li><li>第2部分：key1:value1</li><li>第2部分：key2:value2</li><li>第2部分：key3:value3</li><li>第2部分：Content-Type</li><li>第2部分：Host</li><li>第2部分：User-Agent</li><li>第3部分：一个回车(\n)</li><li>第4部分：要上传的数据</li></ul><p>请求最多包含4部分，最少包含3部分，第4部分<strong>可为空</strong>。</p><p>💡 <strong>请求方法动词有：</strong></p><p><code>GET</code> <strong>|</strong> <code>POST</code> <strong>|</strong> <code>PUT</code> <strong>|</strong> <code>PATCH</code> <strong>|</strong> <code>DELETE</code></p><p>💡 路径默认为“/”,路径包括<code>查询参数</code>，但不包括<code>锚点</code>。</p><p>✔ /search?keyword=SASS&amp;type=courses&amp;page=1</p><p>× /search?keyword=SASS&amp;type=courses&amp;page=1#2</p><p>💡 第2部分Content-Type标注了第4部分内容的格式</p><p>💡 要上传的数据最常见的是用户名和密码</p><p>💡 查看第四部分内容在FormData或Request Payload中。</p><h3 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h3><ol><li>状态行 「协议/版本号 状态码 状态描述」</li><li>响应头</li><li>空行</li><li>响应数据正文</li></ol><h3 id="响应具体格式"><a href="#响应具体格式" class="headerlink" title="响应具体格式"></a>响应具体格式</h3><ul><li><p>第1部分：协议/版本号 状态码 状态解释</p></li><li><p>第2部分：key1: value1</p></li><li><p>第2部分：key2: value2</p></li><li><p>第2部分：Content-Length</p></li><li><p>第2部分：Content-Type(标注第4部分格式) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如text/html | application/javascript | json | image/png</span><br></pre></td></tr></table></figure></li><li><p>第3部分：一个回车(\n)</p></li><li><p>第4部分：要下载的内容</p></li></ul><p>💡 第2部分Content-Type标注了第4部分内容的格式</p><p>💡 第2部分中的Content-Type遵循MIME规范</p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul><li>1xx 不常用</li><li>2xx 表示成功</li><li>3xx 表示滚吧    301表示搬家了永远不回来了,302表示临时外出可能以后还回来</li><li>4xx 表示你错了  (<strong>访问者</strong>出错了，例如地址打错了等)</li><li>5xx 表示好吧,我错了    (<strong>服务器</strong>出错了，例如服务器挂了、服务器停止了) </li></ul><p><code>状态码是服务器对浏览器说的话，需要记住。</code></p><p><strong>常见状态</strong></p><ul><li>200 OK 客户端请求成功</li><li>301：Move Permanently 永久重定向，请求的资源已被永久的移动到新URI</li><li>302：Found 临时重定向 与301类似，但资源只是临时被移动</li><li>400 Bad Request 客户端请求的语法错误，服务器无法理解</li><li>403 Forbidden 服务器拒绝执行此请求</li><li>404 Not Found 请求的资源不存在，例如，输入了错误的URL</li><li>500 Internal Server Error 服务器内部错误，无法完成请求</li><li>502 服务器网关错误，收到无效响应</li></ul><p>请求和响应的第一部分都含有 <code>协议/版本号</code></p><blockquote><p><strong>查看请求和响应的方法</strong></p></blockquote><p>打开浏览器开发者工具Developer Tools，Network选项卡，右键添加Method页签(如果没有的话。)</p><p>Method页签看GET或POST方法，status看状态码，protocol看协议/版本号，type看类型可以为document、script、png等</p><p><img src="chrome-tab.png" alt="chrome-tab"></p><p>然后在Name页签点一下你想要查看的URI</p><p>在右侧弹出页的Headers,有General、Response Headers、Request Headers等信息</p><p><img src="chrome-rr.png" alt="chrome-rr"></p><p>General</p><blockquote><p>Request URL: <a href="https://xiedaimala.com/" target="_blank" rel="noopener">https://xiedaimala.com/</a></p><p>Request Method: GET</p><p>Status Code: 200 OK</p><p>Remote Address: 114.215.175.213:443</p><p>Referrer Policy: no-referrer-when-downgrade</p></blockquote><p>在Response Headers或Request Headers想查看响应或请求详情，关键来了：</p><p><code>点击view source</code></p><p><code>点击view source</code></p><p><code>点击view source</code></p><p>Response Headers/Request Headers<strong>右侧浅色小字</strong></p><p>这儿可以<code>查看到请求|响应内容的前3部分</code></p><p>🌀 请求的第4部分数据在Form Data或Request Payload中查看 [<em>GET请求没有第4部分数据</em>]</p><p><img src="request-chrome.png" alt="chrome-request4"></p><hr><p>🌀 响应的第4部分数据在Preview或Response的tab中查看</p><p><img src="response-chrome.png" alt="response-chrome4"></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 网络知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/08/31/hello-world/"/>
      <url>/2018/08/31/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML标签那些事儿(上)</title>
      <link href="/2018/08/31/HTML%E6%A0%87%E7%AD%BE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF(%E4%B8%8A)/"/>
      <url>/2018/08/31/HTML%E6%A0%87%E7%AD%BE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF(%E4%B8%8A)/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML标签那些事儿-上"><a href="#HTML标签那些事儿-上" class="headerlink" title="HTML标签那些事儿(上)"></a>HTML标签那些事儿(上)</h2><blockquote><p>故事上篇，我们先概览一下HTML标签的大概全貌。</p></blockquote><p>HTML：超文本标记语言——HyperText Markup Language，它描述并定义了一个网页的内容和基本布局。</p><h3 id="HTML标签大全"><a href="#HTML标签大全" class="headerlink" title="HTML标签大全"></a><code>HTML标签大全</code></h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>!DOCTYPE</td><td>定义文档类型。</td></tr><tr><td>html</td><td>定义   HTML 文档。</td></tr><tr><td>title</td><td>定义文档的标题。</td></tr><tr><td>body</td><td>定义文档的主体。</td></tr><tr><td>h1~h6</td><td>定义   HTML 标题。</td></tr><tr><td>p</td><td>定义段落。</td></tr><tr><td>br</td><td>定义简单的折行。</td></tr><tr><td>hr</td><td>定义水平线。</td></tr><tr><td><!----></td><td>定义注释。</td></tr></tbody></table><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>acronym</td><td>定义只取首字母的缩写。</td></tr><tr><td>abbr</td><td>定义缩写。</td></tr><tr><td>address</td><td>定义文档作者或拥有者的联系信息。</td></tr><tr><td>b</td><td>定义粗体文本。</td></tr><tr><td>bdi</td><td>定义文本的文本方向，使其脱离其周围文本的方向设置。</td></tr><tr><td>bdo</td><td>定义文字方向。</td></tr><tr><td>big</td><td>定义大号文本。</td></tr><tr><td>blockquote</td><td>定义长的引用。</td></tr><tr><td>center</td><td>不赞成使用。定义居中文本。</td></tr><tr><td>cite</td><td>定义引用(citation)。</td></tr><tr><td>code</td><td>定义计算机代码文本。</td></tr><tr><td>del</td><td>定义被删除文本。</td></tr><tr><td>dfn</td><td>定义定义项目。</td></tr><tr><td>em</td><td>定义强调文本。</td></tr><tr><td>font</td><td>不赞成使用。定义文本的字体、尺寸和颜色</td></tr><tr><td>i</td><td>定义斜体文本。</td></tr><tr><td>ins</td><td>定义被插入文本。</td></tr><tr><td>kbd</td><td>定义键盘文本。</td></tr><tr><td>mark</td><td>定义有记号的文本。</td></tr><tr><td>meter</td><td>定义预定义范围内的度量。</td></tr><tr><td>pre</td><td>定义预格式文本。</td></tr><tr><td>progress</td><td>定义任何类型的任务的进度。</td></tr><tr><td>q</td><td>定义短的引用。</td></tr><tr><td>rp</td><td>定义若浏览器不支持 ruby 元素显示的内容。</td></tr><tr><td>rt</td><td>定义 ruby 注释的解释。</td></tr><tr><td>ruby</td><td>定义 ruby 注释。</td></tr><tr><td>s</td><td>不赞成使用。定义加删除线的文本。</td></tr><tr><td>samp</td><td>定义计算机代码样本。</td></tr><tr><td>small</td><td>定义小号文本。</td></tr><tr><td>strike</td><td>不赞成使用。定义加删除线文本。</td></tr><tr><td>strong</td><td>定义语气更为强烈的强调文本。</td></tr><tr><td>sup</td><td>定义上标文本。</td></tr><tr><td>sub</td><td>定义下标文本。</td></tr><tr><td>time</td><td>定义日期/时间。</td></tr><tr><td>tt</td><td>定义打字机文本。</td></tr><tr><td>u</td><td>不赞成使用。定义下划线文本。</td></tr><tr><td>var</td><td>定义文本的变量部分。</td></tr><tr><td>wbr</td><td>定义可能的换行符。</td></tr></tbody></table><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>form</td><td>定义供用户输入的 HTML 表单。</td></tr><tr><td>input</td><td>定义输入控件。</td></tr><tr><td>textarea</td><td>定义多行的文本输入控件。</td></tr><tr><td>button</td><td>定义按钮。</td></tr><tr><td>select</td><td>定义选择列表（下拉列表）。</td></tr><tr><td>optgroup</td><td>定义选择列表中相关选项的组合。</td></tr><tr><td>option</td><td>定义选择列表中的选项。</td></tr><tr><td>label</td><td>定义 input 元素的标注。</td></tr><tr><td>fieldset</td><td>定义围绕表单中元素的边框。</td></tr><tr><td>legend</td><td>定义 fieldset 元素的标题。</td></tr><tr><td>isindex</td><td>不赞成使用。定义与文档相关的可搜索索引。</td></tr><tr><td>datalist    h5</td><td>定义下拉列表。</td></tr><tr><td>keygen</td><td>定义生成密钥。</td></tr><tr><td>output</td><td>定义输出的一些类型。</td></tr></tbody></table><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>frame</td><td>定义框架集的窗口或框架。</td></tr><tr><td>frameset</td><td>定义框架集。</td></tr><tr><td>noframes</td><td>定义针对不支持框架的用户的替代内容。</td></tr><tr><td>iframe</td><td>定义内联框架。</td></tr></tbody></table><h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>img</td><td>定义图像。</td></tr><tr><td>map</td><td>定义图像映射。</td></tr><tr><td>area</td><td>定义图像地图内部的区域。</td></tr><tr><td>canvas</td><td>定义图形。</td></tr><tr><td>figcaption</td><td>定义 figure 元素的标题。</td></tr><tr><td>figure</td><td>定义媒介内容的分组，以及它们的标题。</td></tr></tbody></table><h4 id="音频-视频"><a href="#音频-视频" class="headerlink" title="音频/视频"></a>音频/视频</h4><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>audio</td><td>定义声音内容。</td></tr><tr><td>source</td><td>定义媒介源。</td></tr><tr><td>track</td><td>定义用在媒体播放器中的文本轨道。</td></tr><tr><td>video</td><td>定义视频。</td></tr></tbody></table><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>a</td><td>定义锚。</td></tr><tr><td>link</td><td>定义文档与外部资源的关系。</td></tr><tr><td>nav</td><td>定义导航链接。</td></tr></tbody></table><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>ul</td><td>定义无序列表。</td></tr><tr><td>ol</td><td>定义有序列表。</td></tr><tr><td>li</td><td>定义列表的项目。</td></tr><tr><td>dir</td><td>不赞成使用。定义目录列表。</td></tr><tr><td>dl</td><td>定义自定义列表。</td></tr><tr><td>dt</td><td>定义自定义列表中的项目。</td></tr><tr><td>dd</td><td>定义自定义列表中项目的描述。</td></tr><tr><td>menu</td><td>定义命令的菜单/列表。</td></tr><tr><td>menuitem</td><td>定义用户可以从弹出菜单调用的命令/菜单项目。</td></tr><tr><td>command</td><td>定义命令按钮。</td></tr></tbody></table><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>table</td><td>定义表格</td></tr><tr><td>caption</td><td>定义表格标题。</td></tr><tr><td>th</td><td>定义表格中的表头单元格。</td></tr><tr><td>tr</td><td>定义表格中的行。</td></tr><tr><td>td</td><td>定义表格中的单元。</td></tr><tr><td>thead</td><td>定义表格中的表头内容。</td></tr><tr><td>tbody</td><td>定义表格中的主体内容。</td></tr><tr><td>tfoot</td><td>定义表格中的表注内容（脚注）。</td></tr><tr><td>col</td><td>定义表格中一个或多个列的属性值。</td></tr><tr><td>colgroup</td><td>定义表格中供格式化的列组。</td></tr></tbody></table><h4 id="样式-节-很关键"><a href="#样式-节-很关键" class="headerlink" title="样式/节(很关键)"></a>样式/节(很关键)</h4><p><code>(本部分从header开始都是html5新标签)</code></p><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>style</td><td>定义文档的样式信息。</td></tr><tr><td>div</td><td>定义文档中的节。无实际意义，默认渲染块级</td></tr><tr><td>span</td><td>定义文档中的节。无实际意义，默认渲染行内</td></tr><tr><td>header</td><td>定义 section 或 page 的页眉。</td></tr><tr><td>footer</td><td>定义 section 或 page 的页脚。</td></tr><tr><td>seciont</td><td>定义 section。</td></tr><tr><td>article</td><td>定义文章。</td></tr><tr><td>aside</td><td>定义页面内容之外的内容。</td></tr><tr><td>details</td><td>定义元素的细节。</td></tr><tr><td>dialog</td><td>定义对话框或窗口。</td></tr><tr><td>summary</td><td>为details元素定义可见的标题。</td></tr></tbody></table><h4 id="元信息"><a href="#元信息" class="headerlink" title="元信息"></a>元信息</h4><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>head</td><td>定义关于文档的信息。</td></tr><tr><td>meta</td><td>定义关于 HTML 文档的元信息。</td></tr><tr><td>base</td><td>定义页面中所有链接的默认地址或默认目标。</td></tr><tr><td>basefont</td><td>不赞成使用。定义页面中文本的默认字体、颜色或尺寸。</td></tr></tbody></table><h4 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h4><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>script</td><td>定义客户端脚本。</td></tr><tr><td>noscript</td><td>定义针对不支持客户端脚本的用户的替代内容。</td></tr><tr><td>applet</td><td>不赞成使用。定义嵌入的 applet。</td></tr><tr><td>embed</td><td>为外部应用程序（非 HTML）定义容器。</td></tr><tr><td>object</td><td>定义嵌入的对象。</td></tr><tr><td>param</td><td>定义对象的参数。</td></tr></tbody></table><h3 id="可替换元素-可替换标签"><a href="#可替换元素-可替换标签" class="headerlink" title="可替换元素(可替换标签)"></a>可替换元素(可替换标签)</h3><hr><p>他们的展现不是由CSS来控制的。这些元素是一类 外观渲染独立于CSS的 外部对象。</p><p>例如input元素的type属性决定是显示输入框还是显示按钮。</p><p>典型的可替换元素有img、object、video和 表单元素，如textarea、input。 某些元素只在一些特殊情况下表现为可替换元素，例如 audio、canvas。</p><h3 id="空元素-空标签"><a href="#空元素-空标签" class="headerlink" title="空元素(空标签)"></a>空元素(空标签)</h3><hr><p>一个<strong>空元素（empty element）</strong>可能是 HTML，SVG，或者 MathML 里的一个不可能存在子节点（例如内嵌的元素或者元素内的文本）的element。</p><p>在 HTML 中有以下这些空元素：</p><ul><br>    <li>area</li><br>    <li>base</li><br>    <li>br</li><br>    <li>col</li><br>    <li>colgroup when the ‘span’ is present</li><br>    <li>command</li><br>    <li>embed</li><br>    <li>hr</li><br>    <li>img</li><br>    <li>input</li><br>    <li>keygen</li><br>    <li>link</li><br>    <li>meta</li><br>    <li>param</li><br>    <li>source</li><br>    <li>track</li><br>    <li>wbr</li><br></ul><h3 id="块元素、行内元素"><a href="#块元素、行内元素" class="headerlink" title="块元素、行内元素"></a>块元素、行内元素</h3><hr><p>一个块元素独占一行显示，宽度占据父容器整个空间，通常浏览器会在块级元素前后另起一个新行。</p><p>多个行内元素可以在同一行显示，默认行内元素不会以新行开始</p><p>常见行内元素：</p><p><strong>span、img、a、lable、input、abbr、em、big、cite、i、q、textarea、select、small、sub、sup，strong、u、button</strong></p><p>常见块元素：</p><p><strong>div、p、h1~h6、ul、ol、dl、li、dd、table、hr、blockquote、address、table、menu、pre，HTML5新增的header、section、aside、footer等</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客个性域名设置</title>
      <link href="/2018/08/30/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AA%E6%80%A7%E5%9F%9F%E5%90%8D%E8%AE%BE%E7%BD%AE/"/>
      <url>/2018/08/30/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AA%E6%80%A7%E5%9F%9F%E5%90%8D%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="有个性！给Hexo博客设置个性域名"><a href="#有个性！给Hexo博客设置个性域名" class="headerlink" title="有个性！给Hexo博客设置个性域名~"></a>有个性！给Hexo博客设置个性域名~</h2><p>博客原地址：superman285.github.io</p><h3 id="查询博客对应的ip地址"><a href="#查询博客对应的ip地址" class="headerlink" title="查询博客对应的ip地址"></a>查询博客对应的ip地址</h3><ul><li><p>nslookup superman285.github.io</p></li><li><p>ping superman285.github.io</p></li></ul><h3 id="域名解析设置方法"><a href="#域名解析设置方法" class="headerlink" title="域名解析设置方法"></a>域名解析设置方法</h3><hr><h4 id="namesilo网站设置"><a href="#namesilo网站设置" class="headerlink" title="==namesilo网站设置=="></a>==namesilo网站设置==</h4><p><em>第一步</em></p><p><img src="1535599403648.png" alt="1535599403648"></p><p><em>第二步</em></p><p><img src="1535599527106.png" alt="1535599527106"></p><p><em>第三步</em></p><p><img src="hexo博客个性域名设置\1535599626098.png" alt="1535599626098"></p><p>点击 ==Apply Template==，此模板为github专用，点击后会智能地为你设置好ip地址。</p><p><img src="1535599679584.png" alt></p><p>选择==Accept==，然后    在上方生成==Existing Resource Records==</p><p>然后可以再各自单独设置TTL，namesilo最小TTL需设置为3600。</p><p>TTL大，修改解析等待生效时间长，但解析访问速度快；(不频繁更换服务器IP可设置大些)</p><p>TTL小，修改等待生效时间短，但稳定性和解析速度慢。</p><p><img src="1535599789246.png" alt></p><p>此处为防止<a href="http://www.skr.dog无法解析，加个www的保险。" target="_blank" rel="noopener">www.skr.dog无法解析，加个www的保险。</a></p><p>实际上github pages的cname会自动帮你解析www，不加也可。(不是100%确定)</p><h4 id="GitHub-Pages设置"><a href="#GitHub-Pages设置" class="headerlink" title="==GitHub Pages设置=="></a>==GitHub Pages设置==</h4><p>hexo博客所在仓库，进入上方菜单的设置界面，下拉到GitHub Pages设置</p><p><img src="1535600362068.png" alt></p><p>设置Custom domain，填入个性域名，skr.dog，点击save，会在仓库Code目录下生成一个CNAME文件(可在第二行加上<a href="http://www.skr.dog，不加也可" target="_blank" rel="noopener">www.skr.dog，不加也可</a>)</p><p><img src="1535600512874.png" alt></p><hr><p>:cherry_blossom:这样就算大功告成啦！！:cherry_blossom:</p><p>需要等待一段时间，不要心急。</p><p>然后在浏览器地址栏输入skr.dog 或者 <a href="http://www.skr.dog，biu一下就跳转到自己的GitHub博客了！" target="_blank" rel="noopener">www.skr.dog，biu一下就跳转到自己的GitHub博客了！</a></p><h3 id="其他个性域名也指向博客"><a href="#其他个性域名也指向博客" class="headerlink" title="其他个性域名也指向博客"></a>其他个性域名也指向博客</h3><p>但是，不完美，因为我们有多个个性域名，如何让他们都指向博客呢。</p><p>GitHub Pages的CNAME只能支持一个域名的配置，无法在这儿入手。</p><p>只能从域名解析商namesilo处入手，让我们的其他个性域名用重定向的方式指向博客(指向skr.dog)。</p><p><em>第一步：</em></p><p>先进行域名解析设置-namesilo网站设置的第一步和第二步，然后先把Existing Resource Records中的几个配置Delete。</p><p><em>第二步：</em></p><p><img src="1535601378531.png" alt></p><p>到这个界面，点击菜单上的Forward Domains，即重定向域名。</p><p><em>第三步：</em></p><p>跳转Domain Forwarding页面后，进行如下配置</p><p><img src="1535601478440.png" alt></p><p>选择301方式。path forwarding为转发，为了可以正常访问网站的二级页面(如skr.dog/about)，选Yes。</p><p>然后在此界面Status状态栏为红色的processing，需要等一下才可以Active<img src="1535601378531.png" alt></p><p>Active后再打开DNS管理界面(点击蓝色球球和上面执行一二步后效果一样)</p><p><img src="1535601825515.png" alt></p><p>发现添加了四项配置，不要手贱删除，这四项的SERVICE都是Forwarding重定向。</p><p><img src="1535601766703.png" alt></p><p>再慢慢地等待一段时间，可能很久……</p><p>:white_flower:大功告成！！:white_flower:</p><p>这时​使用其他个性域名也可以访问博客了，舒服~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令3</title>
      <link href="/2018/08/29/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A43/"/>
      <url>/2018/08/29/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A43/</url>
      
        <content type="html"><![CDATA[<h3 id="3个git命令"><a href="#3个git命令" class="headerlink" title="3个git命令"></a>3个git命令</h3><hr><p>①git init  </p><p>将所在目录初始化为git仓库。</p><p>会在目录生成一个.git子文件夹，包含git操作所需要的内容。</p><img src="/2018/08/29/git常用命令3/init.png" title="init配图"><p>②git add 将文件内容改动添加到暂存区，但文件改动并没有真正进入版本库中，而是处于中间状态。</p><img src="/2018/08/29/git常用命令3/add.png" title="add配图"><p>③git commit -v  提交时显示内容差异对比。</p><p>提交时：</p><img src="/2018/08/29/git常用命令3/commitv-1.png" title="commit配图"><img src="/2018/08/29/git常用命令3/commitv-2.png" title="commit配图"><p>提交后：</p><img src="/2018/08/29/git常用命令3/commitv-3.png" title="commit配图">]]></content>
      
      
      
        <tags>
            
            <tag> git命令 </tag>
            
            <tag> Hexo Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux命令</title>
      <link href="/2018/08/28/linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/08/28/linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h4 id="linux四个命令"><a href="#linux四个命令" class="headerlink" title="linux四个命令"></a>linux四个命令</h4><hr><ol><li><p>ls ls即list的简写，意为罗列。罗列出当前目录下的文件信息。</p><img src="/2018/08/28/linux命令/ls1.png" title="ls1配图"><p>常用参数为 -a -l  合写-al</p><p>-a 为罗列所有文件，包括隐藏文件(命名以.开头的文件)和隐藏目录。</p><p>-l 为罗列所有文件详细信息，包括大小、权限、时间等。</p></li><li><p>cat，concatenate的简写。</p><p>连接文件并打印到显示设备上，一般用于显示文件的内容。</p></li><li><p>mv move的简写。用于移动或重命名文件。</p><p>mv 文件名 目标路径 ；即移动文件  e.g. mv 1.txt dir2/</p><p>mv 文件名 新文件名 ；即重命名文件  e.g. mv 1.txt 2.txt</p></li><li><p>touch 用于新建文件或改变文件更新时间。</p><p>不存在文件1.txt时，touch 1.txt，意为新建1.txt文件；</p><p>1.txt存在后，再使用touch 1.txt，意为改变文件的更新时间。</p></li></ol><h4 id="explainshell-com网站用法"><a href="#explainshell-com网站用法" class="headerlink" title="explainshell.com网站用法"></a>explainshell.com网站用法</h4><hr><p>打开网站在搜索框输入完整命令(可以带参数)</p><p>鼠标分别移动到命令处或某个参数处，即可看到对应指向框中的具体含义，如图所示。</p><img src="/2018/08/28/linux命令/exshell.png" title="explainshell配图">]]></content>
      
      
      
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开博大吉</title>
      <link href="/2018/08/28/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/"/>
      <url>/2018/08/28/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</url>
      
        <content type="html"><![CDATA[<h3 id="开博大吉"><a href="#开博大吉" class="headerlink" title="开博大吉"></a>开博大吉</h3><hr><p>Hexo博客正式开张!!</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
